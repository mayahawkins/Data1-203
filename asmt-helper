;;; =========================
;;;  CMPU-365, Spring 2013
;;;  Maya T. Hawkins
;;;  asmt-helper.lisp
;;; =========================
;;;  Some Helpful Functions when doing assignments.

;;;  TESTER
;;; ----------------------------
;;;  INPUT:  EXPR, anything
;;;  OUTPUT:  NIL
;;;  SIDE EFFECT:  Displays EXPR both before and after evaluation
;;; ----------------------------
;;;  Best used when the evaluation of EXPR does not cause any
;;;  side-effect printing.  Note, when calling this function
;;;  you should quote the expression of interest.  For example,
;;;  compare (tester (+ 1 2)) and (tester '(+ 1 2)) in the
;;;  Interactions Window.

(defun tester (expr)
  ;; NOTE:  FORMAT expressions evaluate to NIL
  (format t "~A ==> " expr)
  (format t "~A~%~%" (eval expr)))

(defun testy (expr)
  ;; NOTE:  FORMAT expressions evaluate to NIL
  (format t "~A ~%==> " expr)
  (eval expr))
;;;  PRINT-ASMT-HEADER
;;; ------------------------------
;;;  INPUTS:  NAME, your name (a string or symbol)
;;;           NUM, the assignment number (an integer)
;;;  OUTPUT:  nil
;;;  SIDE EFFECT: Displays a nice header in the "interactions window".

(defun print-asmt-header (name num)
  (format t "====================================~%")
  (format t "  CMPU-365, Spring 2013~%")
  (format t "  Asmt. ~A~%" num)
  (format t "  ~A~%" name)
  (format t "====================================~%~%"))

;;;  PRINT-PROBLEM-HEADER
;;; ---------------------------------
;;;  INPUT:  INFO, some information about an assignment problem
;;;  OUTPUT:  NIL
;;;  SIDE EFFECT:  Prints a nice header for an assignment problem
;;;   in the interactions window.

(defun problem (str)
  (format t "-------------------------~%")
  (format t " PROBLEM ~A~%" str)
  (format t "-------------------------~%~%"))

(defvar *mt-tree* '_)

(defun mt-tree?
    (thing)
  (equal thing *mt-tree*))

(defstruct node lefty datum righty)

(defun print-n-spaces
    (n)
  (cond
   ((<= n 0) NIL)
   (T
    (format t " ")
    (print-n-spaces (- n 1)))))

(defun print-bin-tree-helper
  (tree indent)
    (cond  
      ;; Base Case:  The TREE is empty
      ((mt-tree? tree)
       ;; Print some spaces to indicate the current depth of the tree
       (print-n-spaces indent)
       ;; and then a vertical bar to indicate a LEAF node
       (format t "|~%"))
      
      ;; Recursive Case:  The TREE is a NODE...
      (T
       ;; Print the RIGHT sub-tree (at indent + 10)
       (print-bin-tree-helper (node-righty tree)
                              (+ indent 10))
       ;; Print the DATUM
       (print-n-spaces indent)
       (format t  "[~A]~%" (node-datum tree))
       ;; Print the LEFT sub-tree (at indent + 10)
       (print-bin-tree-helper (node-lefty tree)
                              (+ indent 10)))))

(defun print-bin-tree
  (tree)
    (format t "~%")
    ;; Call helper function with indentation initially 0
    (print-bin-tree-helper tree 0))

(defvar tree1 (make-node :lefty *mt-tree* :datum 55 :righty *mt-tree*))
(defvar tree2 (make-node :lefty *mt-tree* :datum 23 :righty *mt-tree*))
(defvar tree3 (make-node :lefty tree1 :datum 37 :righty tree2))
(testy '(print-bin-tree tree3))

(defvar tree10 (make-node :lefty *mt-tree* :datum 77 :righty *mt-tree*))
(defvar tree11 (make-node :lefty *mt-tree* :datum 92 :righty *mt-tree*))
(defvar tree12 (make-node :lefty tree10 :datum 100 :righty tree11))
(defvar big-tree (make-node :lefty tree3 :datum 999 :righty tree12))
(testy '(print-bin-tree big-tree))
